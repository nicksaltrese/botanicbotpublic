
# in this approach every flow is made of individual nodes, 
# each flow element/node has its own purpose and behaviour
#
# flowId is a unique identifier which identifies a specific flow, ideally it would be a UUID
# so far we have node with types root, choice, question, message, process and end
# each node will have different attributes
# these types are not final, we may add more types or merge few types into single type, for
# eg., in the existing types we can actually merge question & message types
#	
# each flow will have :
#			id - this is nothing but the flow id, 
#					an unique identifier,
#					which would be UUID
#					automatically generated by the UI
#
# 			name - friendly name or purpose of this flow,
# 					given by bot/flow developer
#
#			nodes - an array of individual node(s)
#
# node :
# 			id - an unique identifier(with in the flow) to identify a node,
#					automatically generated by the UI
#			name - friendly name or purpose of this node,
# 					given by bot/flow developer
#			type - purpose of this node chosen by bot/flow developer
#			msg - a message which need to be shown to the end user, 
#					given by bot/flow developer
#			data - any data that need to be shown to user along with message, 
#					given by bot/flow developer
#			connections - the possible paths the flow can take after execution this node,
#					given by bot/flow developer
#
# node of type - root :
#			will have id, name, type, connections attributes
#			purpose is to say from which node the exuction is about to start
#
# node of type - choice :
#			will have id, name, type, connections, msg and data attributes
#			purpose is to ask user a question with possible choices to choose from
#
# node of type - question :
#			will have id, name, type, connections and msg attributes
#			purpose is to ask user a question
#
# node of type - message :
#			will have id, name, type, connections and msg attributes
#			purpose is to show user a message
#
# node of type - process :
#			will have id, name, type, connections and msg attributes
#			purpose is to do some processing
#
# node of type - end :
#			this node itself doesn't exist in the flow, hence will not have any attributes4
#			purpose is to say end of flow
#
# connections :
#			an array of connection(s), ie., possible paths from a node to other nodes
#
# connection :
#			a single path from a node to another node
#			will have default and if attributes
#
#			default - its value is a node which indicates where to move next
#
#			if - it is an object which has few attributes
#				op - an operator
#				value - a value to which comparison need to happen
#				context - location from which a value need to be taken to compare with
#				then - its value is a node which indicates where to move next provided the
#						condition is true 

topic: ~FlowExecutor system repeat ()

# sees if the flow id exits and flowelemet is null, then executes the output part
t: START($flowInfo.flowId !$flowInfo.flowElement)
	$_elementId = ^PrepareForFlowExecution($flowInfo.flowId)
	^StartElementExecution($_elementId)

# this rule takes the reponsibility of taking care of node type choice
t: QUESTION_WITH_CHOICE ($flowInfo.flowElement $$flowElementType=choice)
	$_msg = ^GetRandomMessage($flowInfo.flowElement.msg)
	$_msg = ^PrepareChoice($flowInfo.flowElement.data null null $_msg)
	$_msg

	a: ()
		$_userInput = ^ChoiceResponded() # gives the choice chosen by user
		if($flowInfo.flowId == PersonalityExecutor) 
		{
			^UpdateUserAnswer($_userInput)
		}
		^StoreAnswer($flowInfo.flowElement.name $_userInput)
		^ExecuteConnections() # executes the connections to find where to move next

# this rule takes the reponsibility of taking care of node type process
t: PROCESS ($flowInfo.flowElement $$flowElementType=process)
	$$flowElementType = null
	^ExecuteConnections() # executes the connections to find where to move next

# this rule takes the reponsibility of taking care of node type question
t: QUESTION ($flowInfo.flowElement $$flowElementType=question)
	$_msg = ^GetRandomMessage($flowInfo.flowElement.msg)
	$_msg

	a:([name ~emailid] {is} _*)
		$_userInput = '_0 # answer given by the user for the question asked
		^StoreAnswer($flowInfo.flowElement.name $_userInput)
		^ExecuteConnections() # executes the connections to find where to move next

	a:(~yes {,} {it} {is} _*)
		$_userInput = '_0 # answer given by the user for the question asked
		^StoreAnswer($flowInfo.flowElement.name $_userInput)
		^ExecuteConnections() # executes the connections to find where to move next		

	a:(_*)
		$_userInput = '_0 # answer given by the user for the question asked
		^StoreAnswer($flowInfo.flowElement.name $_userInput)
		^ExecuteConnections() # executes the connections to find where to move next

# this rule takes the reponsibility of taking care of node type message
t: MESSAGE ($flowInfo.flowElement $$flowElementType=message)
	$_msg = ^GetRandomMessage($flowInfo.flowElement.msg)
	$_msg

	a:(_*)
		$$response = '_0 # response given by the user for the message shown
		^ExecuteConnections() # executes the connections to find where to move next

# this rule takes the reponsibility of taking care of node type message
t: FLOWID ($flowInfo.flowElement $$flowElementType=flowId)
	^LoadChildFlow($flowInfo.flowElement.flowId)

# this rule takes the reponsibility of taking care of connections in a node
t: EXECUTE_CONNECTIONS ($flowInfo.flowElement $$executeConnections)
	$$executeConnections = null
	$$flowElementType = null

	# executes the connections to find the next node that needs execution
	$_connectionsResult = ^ProcessConnections($flowInfo.flowElement)
	if($_connectionsResult AND $_connectionsResult != end)
	{
		# gets the node object from the flow
		$flowInfo.flowElement = ^GetFlowElement($_connectionsResult)
	}
	else
	{
		$$flowElementType = end
	}
	^retry(TOPIC)

# this rule takes the reponsibility of taking care of ending the flow
t: END_FLOW ($flowInfo.flowElement $$flowElementType=end)
	if($flowInfo.flowId == PersonalityExecutor) 
	{
		$_personalityAnalysis = ^GetAnalysis()
		$_msg = $_personalityAnalysis		
	}
	else if($flowInfo.flowId == PrinciplePrototype OR
			$flowInfo.flowId == BotanicChatContactForm) 
	{
		# $$oobjson = ^jsonwrite($flowInfo.userinfo)
		$$oobjson = ^jsonwrite($userInfo)
		if($flowInfo.flowId == PrinciplePrototype) 
		{
			$_msg = ^"information sent to MTOne is : $$oobjson"
		}
	}
	^EndFlow()

	^delete($userInfo)
	$userInfo = null

	if($_msg) { $_msg }

# this rule takes the reponsibility of taking care of identifying the type of the node
t: DO_ELEMENT($flowInfo.flowElement)
	# tries to identify the node type from the node object
	^ProcessElement($flowInfo.flowElement)
